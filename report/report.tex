\documentclass[a4paper]{extarticle}
\input{makros_und_pakete.tex}



\begin{document}
    \begin{center}
        \huge
        \textbf{Forschungsprojekt: Wärmepumpendemonstrator}
            
        \vspace{0.4cm}
        \large
        Demonstratorapp zur Präsentierung der Ergebnisse eines Konvolutionsnetzwerks für Wärmepumpen
            
        \vspace{0.6cm}
        \normalsize
        \begin{tabular}{llll}
            Ursula Krause & (st$X$), & Laurin Röseler & (st177288),\\
            Christof Schuster & (st$X$), & Fabio Tucciarone & (st177167)
        \end{tabular}

        \vspace{0.3cm}
        st$X$@stud.uni-stuttgart.de
        
        \vspace{0.8cm}
    \end{center}

    \begin{abstract}
        Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit...
        Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit...
        Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit...
    \end{abstract}

    \section{Einführung}

    In dieser Projektarbeit soll ein Demonstratorprogramm zur Präsentierung eines von Julia Pelzer trainierten neuronalen Netzwerks
    zur Vorhersage von Wärmepumpen erzeugten Temperaturfeldern entwickelt und vorgestellt werden.
    Dieser Demonstrator soll zur Vermittlung der Ergebnisse an eine Wissenschaftliche und nicht-Wissenschaftliche Zielgruppe dienen.
    Für die nicht-Wissenschaftliche Version soll ein spielerischer Ansatz verwendet werden, 
    um vor allem auch bei Kindern ein Interesse für künstliche Intelligenzen zu wecken, ohne sie miss zu repräsentieren.

    Um dieses Ziel zu erreichen, implementieren wir eine Klientenapp und eine Serveranwendung.
    Die Klientenapp dient zur Darstellung der Ergebnisse und Information aber auch zur Eingabe der Parameter.
    Die Serveranwendung wertet die Modellanfragen aus und antwortet mit den Ergebnissen.

    \subsection{Unterteilung in Stufen}
    
    Im folgenden Bericht werden zwei Phasen oder auch Stufen des Projekts beschrieben.
    Diese Phasen orientieren sich an Pelzers Phasen aus [ZIT]. \todo{Überlegen wie wir uns auf Quellen beziehen!}

    Die erste Phase befasst sich mit der Darstellung einer Wärmepumpe und der Generierung einer Grundwahrheit mittels einer Interpolation von Datenpunken aus einem Rohdatensatz.

    In der zweiten Phase liegt der Fokus auf der Darstellung der Ergebnisse zweier Wärmepumpen und der Veränderung der Position. 
    Es wird dabei keine Grundwahrheit generiert. 

    \section{Projektarchitektur}

    Zunächst möchten wir einen Überblick über die Projektarchitektur und die dazugehörigen Entwurfsentscheidungen geben.
    
    \subsection{Überblick über die Komponenten}

    \begin{figure}[H]
        \centering
        \includegraphics[trim={5cm 3.5cm 5cm 0}, clip, width=0.8\linewidth]{bilder/architektur_projekt.pdf}
        \caption{Grobe Projektarchitektur} \label{fig:architektur-projekt}
    \end{figure}

    Das in Abbildung \ref{fig:architektur-projekt} beschriebene Diagramm zeigt das Zusammenspiel der gröbsten Komponenten des Projekts.
    Auf der linken Seite sind die Benutzerendgeräte dargestellt. 
    Auf diesen kann die sogenannte Demonstrator App gestartet werden.
    Sie ist die Schnittstelle zwischen Benutzer und Modell und dient der Eingabe von Parametern und der Ausgabe der Endergebnisse, 
    die vom Demonstrator Backend generiert werden. \todo{Anmerken: Grafiken von Backend, warum?}
    Die Demonstrator App selbst benötigt keine Datensätze oder Modelle um zu funktionieren, sondern kommuniziert über HTTP-Anfragen mit einem Server.
    Dieser Server kann sowohl lokal auf dem Nutzergerät gestartet werden, als auch auf einem der Institutsserver des IPVS.
    Über die Demonstrator App ist hier bisher jedoch fest der Server \glqq{}pcsgs08\grqq{} vorgegeben.
    Der lokale Server diente dabei während der Entwicklung zum Testen der Funktionalitäten. 

    Die Kommunikation mit dem Institutsserver wird mittels eines ssh-Tunnels realisiert, 
    da von außerhalb des Universitätsnetzwerks sonst keine Verbindung aufgebaut werden kann.
    Der ipvslogin-Weiterleitungsserver wird dabei verwendet, 
    um einen automatisch ausgewählten Port am Endgerät an den Port 5000 des pcsgs08-Servers weiterzuleiten.
    Auch der lokale Server läuft auf Port 5000.

    Als Kommunikationsmethode wurden HTTP-Anfragen gewählt. 
    Diese können in übersichtlicher Art und Weise aufgesetzt und angesprochen werden.
    Da keine Bidirektionale Kommunikation notwendig ist und zurückgesendete Bilddaten als Text in Basis 64 kodiert werden können,
    umfasst HTTP um ausreichend Funktionalität.

    Die Schnittstelle des Backends wurde aufgrund der umfangreichen Dokumentation und Einsteigerfreundlichkeit mit Flask implementiert.
    
    \subsection{Beschreibung des Backends}

    Nun soll ein genauerer Überblick über das Backend anhand des Schaubilds \ref{fig:architektur-backend} angegeben werden.
  
    Das Backend besteht aus einer Flask-Schnittstelle die links dargestellt wird, einem Kommunikations- und Konfigurationsblock in der Mitte
    und der tatsächlichen Modellanwendung und Generierung der Grundwahrheit rechts.
    Um die Modellergebnisse für unsere Zwecke geeignet erzeugen zu können verwenden wir eine angepasste Version des Projekts von Pelzer.
    Dieses soll im Folgenden einfach mit |1HP_NN| abgekürzt werden.

    \begin{figure}[H]
        \centering
        \includegraphics[trim={0cm 6cm 0cm 0}, clip, width=\linewidth]{bilder/architektur_backend.pdf}
        \caption{Grobe Projektarchitektur} \label{fig:architektur-backend}
    \end{figure}

    Auf der Grafik sind die wichtigsten Methoden der Flask-Schnittstelle dargestellt.
    Diese können, sobald der Flask-Server gestartet ist, über |172.0.0.1:PORT/name| angesprochen werden.
    Die Flask-Schnittstelle speichert zur Initialisierung ein Objekt der Klasse |ModelConfiguration| in einen Dateisystem-Cache.
    Dadurch kann für spätere Aufrufe Initialisierungszeit gespart werden.
    |ModelConfiguration| verfügt dabei sowohl über Informationen zu den Datensätzen und Modellen, als auch zur Generierung der Grundwahrheit und den Bildern.

    Mit den blauen Pfeilen sind die Kommunikationspfade für die Anfragen an das Modell gekennzeichnet. \todo{Struktur verbessern}
    Hierfür gibt es zwei Methoden, die mit den Stufen des Projekts korrespondieren. 
    Die erste Methode generiert die Hitzefahne einer Wärmepumpe und eine Grundwahrheit zum Vergleich und die zweite nur ein Temperaturfeld mit zwei Wärmepumpen.
    Beide Methoden geben Objekte der Klasse |ReturnData| zurück. 
    Diese funktioniert so ähnlich wie ein Python |dict|, erlaubt es jedoch direkt Matplotlib-Grafiken zu erstellen und kodiert zwischenzuspeichern.

    Der Ablauf einer solchen Anfrage funktioniert innerhalb des Backends dann folgendermaßen:
    Eine HTTP-Anfrage sendet die nötigen Eingabeparameter, diese werden an die Methoden aus |ModelConfiguration| weitergeleitet.
    Diese rufen die angepassten Funktionen zur Vorbereitung, Modellanwendung und Visualisierung aus |1HP_NN| auf.
    Handelt es sich um eine Anfrage der Stufe 1, wird eine Grundwahrheit generiert und mit dem Modellergebnis verglichen.

    \subsection{Beschreibung des Frontends}

    \todo{Ergänzen}


    \section{Backend}

    Nachdem in den vorherigen Abschnitten ein Überblick über das Projekt und die dazugehörigen Komponenten geschaffen wurde,
    soll im Folgenden genauer auf die Implementierung der beiden Projektphasen im Backend eingegangen werden.

    \subsection{Stufe 1 (1HP NN)}

    \subsubsection{Allgemeines? / Implementierung}

    \subsubsection{Grundwahrheit}

    Es gibt verschiedene Möglichkeiten eine Grundwahrheit als Vergleich zum Modellergebnis zu generieren.
    In allen Fällen ist es das Ziel eine Wärmefahne aus verfügbaren Daten eines Datensatzes mittels einer Interpolation zu generieren.

    Wir stellen im Folgenden einige Varianten einer Interpolationsmethode und vergleichen sie mit dem naiven Ansatz einfach den nächstgelegenen Datenpunkt als Grundwahrheit zu verwenden.
    Mit dem Abstand der Punkte beziehen wir uns hier auf die euklidische Distanz der Modelleingabetupel, 
    die in der ersten Phase nur aus einem Permeabilitätswert und einem Druckwert bestehen, da die Position der Wärmepumpe fest ist.

    
    
    \begin{itemize}
        \item Hauptaufgabe: Generierung einer Grundwahrheit für eine Wärmepumpe
        \begin{itemize}
            \item Algorithmus: Nächster Punkt
            \item Algorithmus: Scipy Versuche (Vergleiche: Laufzeit, Fehler)
            \item Algorithmus: Unser Algorithmus (Vergleiche ...)
        \end{itemize}
        \item Kommunikation mit dem Modell
        \begin{itemize}
            \item Pipeline / Ablauf einer Anfrage
            \item Optimierungen / Engpässe
        \end{itemize}
    \end{itemize}
    \subsubsection{Triangulation}\todo{Umformatieren}

    % nächster Punkt bei Interpolanten, dabei gesucht: minimale Punktabstandssumme Wir wollen ein Dreieck aus drei Datenpunkten, $c, c_1$ und $c_2$ um einen Punkt $p$ legen.
    $Vor"uberlegung:$ Um die Farbe eines Pixels in einer zweidimensionalen Ebene, zufällig verteilter
    Datenpunkte, anzunähern, empfiehlt es sich über ein Dreieck aus Datenpunkten, das den Pixel 
    einschließt zu interpolieren. Dabei, um möglichst viel von den Informationen der Datenpunkte 
    zu nutzen, sollten die drei Datenpunkte einen möglichst geringen Abstand zum Pixelpunkt $p$ 
    besitzen. Die drei Datenpunkte, die das Dreieck bilden sollen, nennen wir $c, c_1$ und $c_2$.
    Bevor wir einen Algorithmus \ref{tri_k} konstruieren, der diese Eigenschaft erfüllt erst noch 
    wichtige Hilfssätze:

    \subsubsection{Hilfssatz 1: Minimales-Abstands-Dreieck beinhaltet nächsten Punkt} \label{tri_hs1}
    Damit ein solches Dreieck eine minimale Punktabstandssumme besitzt,
    ist es notwendig, dass der, zu $p$ nächste, Datenpunkt Teil dieses Dreiecks ist. Diesen Punkt 
    nennen wir $c$.

    \begin{figure*}[!ht]
        \centering	
        \includegraphics[scale=0.10]{bilder/tri_1.pdf}
        \caption{Ziel Triangulation}
        \label{fig:triangulation_1}
    \end{figure*}

    $Beweis:$
    Angenommen, $c$ wäre nicht Teil des $p$-umschließenden Dreiecks mit minimaler Punktabstandssumme.
    Dieses Dreieck bestehe aus den Eckpunkten $a_1$, $a_2$ und $a_3$ mit Abstandssumme:

    \begin{eqnarray*}
        S_{\text{AP}} &=& \mid p - a_1 \mid + \mid p - a_2 \mid + \mid p - a_3 \mid \\
    \end{eqnarray*}
    
    Von den drei Punkten sei $a_1$ der nächste Punkt zu $p$. Dieser spannt, mit $p$ als Mittelpunkt, 
    einen Kreis auf. Innerhalb davon muss $c$ liegen.
    Es gibt nun einen Punkt $\in \{ a_1, a_2, a_3 \}$, der sich durch $c$ ersetzen lässt und
    mit den anderen beiden Punkten ein Dreieck aufspannt, das immer noch $p$ umschließt 
    (siehe \ref{fig:triangulation_2}).

    \begin{figure*}[!ht]
        \centering	
        \includegraphics[scale=0.15]{bilder/tri_2.pdf}
        \caption{Dreiteilung mit Hilfslinien}
        \label{fig:triangulation_2}
    \end{figure*}

    Diesen, zu ersetzenden Punkt, kann man finden, indem man zuerst von jedem Punkt 
    $\in \{ a_1, a_2, a_3 \}$ eine Linie durch $p$ zieht (in Abb. \ref{fig:triangulation_2} lila, 
    grün, rot). Diese Linien, von $p$ ausgehend (nur noch die durchgezogenen Linien), teilen die 
    Ebene in drei Teile auf, wobei in jedem genau ein Punkt $\in \{ a_1, a_2, a_3 \}$ liegt.
    Wäre mehr als ein Punkt in einem Teil, so umschlössen die drei Punkte nicht mehr $p$ 
    (siehe \ref{tri_hs2}).

    \begin{figure*}[!ht]
        \centering	
        \includegraphics[scale=0.15]{bilder/tri_3.pdf}
        \caption{kleineres Dreieck}
        \label{fig:triangulation_3}
    \end{figure*}

    Sei $a_1$ der Punkt, der im selben Teil wie $c$ liegt. Dieser lässt sich durch $c$ ersetzen, 
    da jeder Punkt innerhalb dieses Teils, ein $p$ umschließendes Dreieck mit $a_2$ und $a_3$ 
    aufstellen würde. Das liegt daran, dass die Mindestgröße der 
    Winkel an jeweils $a_2$ und $a_3$ ausreicht, um $p$ zu umschließen (siehe \ref{tri_hs2}).
    Die Mindestgröße beider Winkel wird schließlich von dem Teil bestimmt, der $a_1$ beinhaltet.
    Das neue Dreieck ($c$,$a_2$,$a_3$) hat somit die Punktabstandssumme:

    \begin{eqnarray*}
        S^*_{\text{AP}} &=& \mid p - c \mid + \mid p - a_2 \mid + \mid p - a_3 \mid \\
    \end{eqnarray*}

    O.B.d.A: $S^*_{\text{AP}}$ ist kleiner als $S_{\text{AP}}$, da der Abstand von $c$ zu $p$
    kleiner ist als der von $a_1$ zu $p$. Das ist ein Widerspruch zur Annahme, dass 
    ($a_1, a_2, a_3$) das Dreieck mit kleinster Punktabstandssumme ist. Daraus folgt, dass der 
    nächste Punkt Teil dieses Dreiecks sein muss. $\square$

    \subsubsection{Hilfssatz 2: Winkel-Punkteinschluss} \label{tri_hs2}
    Zwei Punkte $a_2, a_3$, die mit einem Punkt $p$ eine Fläche $f_{a_1}$ (blau, Abb. 
    \ref{fig:triangulation_hilfssatz_2}) hinter $p$ projizieren, 
    erzeugen mit jedem Punkt $a_1$ aus $f_{a_1}$ ein Dreieck, das $p$ umschließt. \\
    $Beweis:$ Seien $a_2, a_3$ und $p$ Punkte auf einer zweidimensionalen Fläche und $\varphi_2, 
    \varphi_3$ die kleineren Winkel (d.h. $\varphi_2, \varphi_3$ < 90°) zwischen den Linien 
    $ \{ (a_2,a_3),(a_2,p) \} $ bzw. $ \{ (a_3,a_2),(a_3,p) \} $.
    
    \begin{figure*}[!ht]
        \centering	
        \includegraphics[scale=0.15]{bilder/tri_hilfssatz.pdf}
        \caption{Winkel-Punkteinschluss}
        \label{fig:triangulation_hilfssatz_2}
    \end{figure*}

    Um $p$ nun in einem Dreieck mit $a_2$ und $a_3$ einzuschließen, muss der 
    dreiecksvervollständigende Punkt $a_1$ so liegen, dass gilt:
    $ \{ (a_2,a_3),(a_2,a_1) \} \geq \varphi_2 $ bzw. $ \{ (a_3,a_2),(a_3,a_1) \} \geq \varphi_3 $, 
    denn sonst würde mindestens eine Linie zwischen $p$ und $(a_3,a_2)$ verlaufen, was $p$ 
    ausschließt. Alle Punkte $a_1$, die 
    $ \{ (a_2,a_3),(a_2,a_1) \} \geq \varphi_2 \land \{ (a_3,a_2),(a_3,a_1) \} \geq \varphi_3 $ 
    erfüllen, liegen also per Definition in $f_{a_1}$. $\square$

    \subsubsection{Konstruktion} \label{tri_k}
    Zuerst durchsuche man die Datenpunkte nach dem, an $p$ nächstgelegenen. Dieser ist Teil des 
    Dreiecks minimaler Punktabstandssumme und wir nennen ihn $c$ (\ref{tri_hs1}). Wir teilen die 
    Ebene mit einer Geraden, die durch $c$ und $p$ verläuft. Orthogonal zu dieser legen wir eine 
    weitere Gerade, die durch $p$ geht (in Abb. \ref{fig:konstuktion} rot). 

    \begin{figure*}[!ht]
        \centering	
        \includegraphics[scale=0.15]{bilder/tri_konstr.pdf}
        \caption{Konstruktion}
        \label{fig:konstuktion}
    \end{figure*}

    Die beiden Quadranten, die nicht an $c$ angrenzen (in Abb. \ref{fig:konstuktion} grün und blau),
    werden verwendet, um Datenpunkte $c_1$ bzw. $c_2$, in jedem der beiden Quadranten einer, zu 
    finden, die mit $c$ ein $p$-umschließendes Dreieck bilden. Dazu nimmt man in beiden Quadranten 
    den nächsten Punkt zu $c$. Die Punkte $c$, $c_1$ und $c_2$ liefern so ein Dreieck mit einer
    einigermaßen kleinen Punktabstandssumme.

    \subsubsection{Laufzeit}
    Der Algorithmus läuft in linearer Laufzeit, da sich das k-kleinste Element einer unsortierten
    Liste in Linearzeit finden lässt. %TODO

    \subsubsection{Selbstkritische Beleuchtung der Konstruktion}
    Die Konstruktion erzeugt schlechte Ergebnisse, falls in mindestens einem der beiden 
    Suchquadranten keine oder sehr weit von $p$ entfernte Datenpunkte liegen, weil die an $c$ 
    angrenzenden Quadranten ignoriert werden, obwohl darin ebenfalls Punkte liegen könnten, die 
    für eine kleinere Punktabstandssumme sorgen würden (siehe Abb. \ref{fig:konstuktion}).
    Ein Lösungsansatz dafür bestünde, indem man beispielsweise zuerst den nächsten Punkt zu $p$ 
    von beiden Quadranten sucht, z.B. $c_1$ und mit diesem dann den möglichen Bereich für $c_2$ 
    absteckt (siehe \ref{tri_hs2}). Dies würde allerdings eine sequentielle Suche nach $c_1$ und $c_2$ verlangen, 
    während unsere Konstruktion Parallelisierung zulässt. \\
    Ein sehr guter Aspekt an der Abstandsminimierung des ersten Punkts $c$ ist, dass, falls $p$ nahe 
    oder auf einem Datenpunkt liegt, die Abweichung von den Messdaten sehr gering ist. \\
    Eine weitere, hervorragende Eigenschaft ist, das sich die Konstruktion in Form eines Algorithmus 
    mit linearer Laufzeit implementieren lässt.

    \section*{SAG MIR BESCHEID, BEVOR DU WAS LÖSCHT, FABIO}
    
    \subsection{Stufe 2 (2HP NN)}
    \begin{itemize}
        \item Generierung einer Grundwahrheit? Warum nicht?
        \item Kommunikation mit dem Modell
        \begin{itemize}
            \item Pipeline / Ablauf einer Anfrage
            \item Optimierungen / Engpässe
        \end{itemize}
    \end{itemize}

    \section{Nutzeroberfläche}

    Unterteilung in Kinderversion und wissenschaftliche Version?
    Farbliche Gestaltung
    
    \subsection{Wissenschaftliche Version}
    \begin{itemize}
        \item Abstriche in der Darstellung
    \end{itemize}

    \subsection{Kinderversion}
    \begin{itemize}
        \item Kinderversion: Nutzernamenvergabe
        \item Einführung und Vereinfachung des Themas für Kinder 
        \item Anreize / Spielifizierung: KI Charakter
        \item Frage: Wie stellt man eine KI dar?
    \end{itemize}
    
    \section{Diskussion}
    \subsection{Nutzeroberfläche}
    \subsection{Backend}
    \subsection{Weiterführende Ideen}

    \section{Fazit}

    \bibliographystyle{apalike}
    \bibliography{quellen.bib}
    
\end{document}